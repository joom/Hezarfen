# Hezarfen

An Idris implementation of a theorem prover for [Roy Dyckhoff's
LJT](https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf), a sequent
calculus for propositional intuitionistic logic that is decidable and does
_not_ need loop checking.  Ported from [Ayberk Tosun's Standard ML
implementation](https://github.com/ayberkt/sequents).

The main goal of the project is to make use of the [elaborator
reflection](http://docs.idris-lang.org/en/latest/reference/elaborator-reflection.html).
Similar to [Lennart Augustsson's Djinn](https://github.com/augustss/djinn), a
theorem prover that generates Haskell expressions, Hezarfen generates Idris expressions.
Unlike Djinn, Hezarfen is not a standalone program, it is a library that
generates Idris expressions of the type `Raw`, one of the types used for the
inner representation of the core language of Idris. This means these
expressions can easily be spliced into your programs. Hezarfen provides a
tactic that lets you do this:

```idris
f2 : (a -> b) -> (b -> c) -> (c -> d) -> a -> d
f2 = %runElab hezarfenExpr
```

However, instead of creating proof terms, you can also create definitions that
are more readable when you print their definitions.

```idris
f2 : (a -> b) -> (b -> c) -> (c -> d) -> a -> d
%runElab (hezarfen `{f2})

demorgan3 : Either (Not p) (Not q) -> Not (p, q)
%runElab (hezarfen `{demorgan3})

contrapositive : (p -> q) -> (Not q -> Not p)
%runElab (hezarfen `{contrapositive})
```

It can also make use of your existing lemmas:

```idris
evenOrOdd : (n : Nat) -> Either (Even n) (Odd n)
... -- some definition of an existing lemma

oddOrEven : (n : Nat) -> Either (Odd n) (Even n)
%runElab (add [`{evenOrOdd}] >>= hezarfen' `{oddOrEven})

-- something more complex, but passing the constructors for Even and Odd
evenOrOddSS : (n : Nat) -> Either (Even (S (S n))) (Odd (S (S n)))
%runElab (add [`{evenOrOdd}, `{EvenSS}, `{OddSS}] >>= hezarfen' `{evenOrOddSS})
```

The last example is beyond the logic Hezarfen is trying to decide. `Even n` and `Even (S (S n))` happen to be one function away, namely `EvenSS`.

For details, look at [Examples.idr](https://github.com/joom/hezarfen/blob/master/Examples.idr).

## Future Work

Some support for deriving terms with type classes can be implemented, à la Djinn.

One of the end goals of Hezarfen is to generate proofs that are easy to read:

* Fresh variable names should be readable. Currently there is a hacky `fresh` function in [Prover.idr](https://github.com/joom/hezarfen/blob/master/Hezarfen/Prover.idr) that attempts to do that.
* There is [already some work on simplifying the proof terms](https://github.com/joom/hezarfen/blob/master/Hezarfen/Simplify.idr) generated by Hezarfen. There are some tricks Hezarfen can learn from Haskell's [pointfree](https://hackage.haskell.org/package/pointfree) package. ([web version](http://pointfree.io/))
* Currently Hezarfen primarily generates expressions as proofs. However when we are writing functions, we often use function definitions instead of lambda terms, and we pattern match on pairs in the function definition, instead of writing `let a = fst p in let b = snd p in ...` or `case p of (x, y) => ...` to do projections. There is [some work](https://github.com/joom/hezarfen/blob/master/Hezarfen/FunDefn.idr) on translating these proof terms to readable function definitions.

The definition it generates looks like this:
```idris
> :printdef contrapositive
contrapositive : (p -> q) -> Not q -> Not p
contrapositive c d = void . d . c
```

As opposed to proof term:
```idris
contrapositive : (p -> q) -> Not q -> Not p
contrapositive = \i20, j20 => void . j20 . i20
```

***

*hezarfen* (/hezaɾfæn/, sounds like "has are fan") is a Turkish word that means
polymath, literally "a thousand sciences".
